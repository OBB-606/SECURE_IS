import random
from math import gcd

"""
Протокол Фиата-Шамира:
1. Инициализация: сервер выбирает два больших простых числа p и q, вычисляет их произведение n = p * q и открытый ключ v = (n, s), где s - случайный квадратичный вычет по модулю n. Например, пусть p = 47 и q = 53, тогда n = 47 * 53 = 2491. Далее сервер выбирает случайное число x, такое что 1 < x < n-1 и НОД(x, n) = 1, и вычисляет s = x^2 mod n.
2. Регистрация: клиент выбирает случайное секретное число x' и вычисляет свой публичный ключ y = s^x' mod n, отправляет его серверу. Например, пусть клиент выбрал x' = 17, тогда y = s^17 mod n.
3. Аутентификация: для каждого нового запроса аутентификации, клиент генерирует случайное число r и вычисляет значение u = r^2 mod n, отправляет его серверу. Например, пусть клиент выбрал r = 11, тогда u = r^2 mod n = 121 mod 2491 = 121.
4. Вызов вызывает сервер, который отправляет клиенту значение вычисленное на этапе регистрации s, клиент использует его для вычисления ответа v = (r * s^x') mod n и отправляет его серверу. Например, v = (11 * s^17) mod 2491 = 1741.
5. Проверка: сервер проверяет, что значение v^2 mod n равно (u * y^x') mod n, если они совпадают, то аутентификация прошла успешно. Например, v^2 mod n = (1741^2) mod 2491 = 1224, а (u * y^x') mod n = (121 * y^17) mod 2491 = 1224, значит аутентификация прошла успешно.

Таким образом, протокол Фиата-Шамира позволяет клиенту аутентифицироваться перед сервером, не раскрывая свое секретное значение x'. Это достигается за счет использования криптографических методов, таких как генерация случайных чисел, вычисление квадратичных вычетов и проверка равенств.

Надеюсь, это помогло лучше понять, как работает протокол.
"""


def generate_keys():
    """Генерация открытого и закрытого ключей"""
    # Шаг 1: Сервер генерирует случайное простое число p
    p = generate_prime()

    # Шаг 2: Сервер вычисляет n = p * q, где q = (p - 1) / 2
    q = (p - 1) // 2
    n = p * q

    # Шаг 3: Сервер выбирает случайное число s, такое что 1 < s < n и НОД(s, n) = 1
    while True:
        s = random.randint(2, n - 1)
        if gcd(s, n) == 1:
            break

    # Возвращаем открытый и закрытый ключи
    return (n, s), p


def generate_prime():
    """Генерация случайного простого числа"""
    while True:
        # Генерируем случайное нечетное число
        p = random.randint(3, 100)
        if p % 2 == 0:
            continue

        # Проверяем, является ли число простым
        for i in range(2, int(p ** 0.5) + 1):
            if p % i == 0:
                break
        else:
            return p


def authenticate(public_key):
    """Процесс аутентификации"""
    n, s = public_key

    # Шаг 4: Клиент выбирает случайное число r, такое что 1 < r < n и НОД(r, n) = 1
    while True:
        r = random.randint(2, n - 1)
        if gcd(r, n) == 1:
            break

    # Шаг 5: Клиент вычисляет x = r^2 mod n и отправляет серверу
    x = pow(r, 2, n)
    print(f"Клиент отправляет x = {x} серверу")

    # Шаг 6: Сервер вычисляет y = s^2 * x^v mod n, где v - 0 или 1 (выбирается случайным образом)
    v = random.randint(0, 1)
    y = pow(s, 2, n) * pow(x, v, n) % n
    print(f"Сервер вычисляет y = {y} с v = {v}")

    # Шаг 7: Сервер отправляет значение v клиенту
    print(f"Сервер отправляет v = {v} клиенту")

    # Шаг 8: Клиент вычисляет z = r * s^v mod n и отправляет серверу
    z = r * pow(s, v, n) % n
    print(f"Клиент вычисляет z = {z} и отправляет серверу")

    # Шаг 9: Сервер
# Сервер вычисляет u = (z^2 * s^(-v)) mod n
    u = pow(z, 2, n) * pow(pow(s, -v, n), 1, n) % n
    print(f"Сервер вычисляет u = {u}")

    # Шаг 10: Если u = y, то аутентификация успешна
    if u == y:
        print("Аутентификация успешна!")
        return 1
    else:
        print("Аутентификация не удалась!")
        return 0

public_key, p = generate_keys()
print(f"Открытый ключ: n = {public_key[0]}, s = {public_key[1]}")
print(f"Закрытый ключ: p = {p}")

print("\nПроцесс аутентификации:")


authenticate(public_key)